Folder Structure
--------------------------------------------------
/
    lib.rs
    main.rs
api/
    auth.rs
    error.rs
    mod.rs
    state.rs
    models/
        mod.rs
        request/
            auth_models.rs
            mod.rs
            report_models.rs
            user_models.rs
        response/
            auth_models.rs
            health_models.rs
            mod.rs
            report_models.rs
            user_models.rs
    routers/
        auth.rs
        health.rs
        mod.rs
        report_routes.rs
        user_routes.rs
application/
    mod.rs
    services/
        auth_service.rs
        board_service.rs
        health_service.rs
        mod.rs
        report_service.rs
        user_onboarding_service.rs
        user_service.rs
config/
    app_config.rs
    mod.rs
domain/
    mod.rs
    models/
        auth.rs
        board.rs
        health.rs
        mod.rs
        report.rs
        user.rs
    ports/
        mod.rs
        storage_port.rs
    repositories/
        board_repository.rs
        mod.rs
        report_repository.rs
        user_repository.rs
infrastructure/
    mod.rs
    container/
        mod.rs
        service_container.rs
    database/
        mod.rs
        sqlite.rs
    frontend/
        frontend_service.rs
        mod.rs
    repositories/
        mod.rs
        sqlite_board_repository.rs
        sqlite_report_repository.rs
        sqlite_user_repository.rs
    security/
        mod.rs
        password_hasher.rs
    storage/
        file_system_storage.rs
        mod.rs


File Contents
--------------------------------------------------


./src/lib.rs
File type: .rs
pub mod api;
pub mod application;
pub mod config;
pub mod domain;
pub mod infrastructure;


--------------------------------------------------
File End
--------------------------------------------------


./src/main.rs
File type: .rs
use std::net::SocketAddr;

use axum::Router;
use rebug::{
    api::{routers::get_api_routes, state::AppState},
    config::app_config::APP_CONFIG,
    domain::models::user::UserRole,
    infrastructure::{
        container::service_container::ServiceContainer, database::sqlite::Sqlite,
        frontend::frontend_service::FrontendService,
    },
};
use tower_http::{
    services::ServeDir,
    trace::{self, TraceLayer},
};
use tracing::Level;
use tracing_subscriber::{EnvFilter, FmtSubscriber};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    setup_tracing();

    let sqlite_connection = &Sqlite::new(APP_CONFIG.database_url.clone()).await?;

    let container = ServiceContainer::new(sqlite_connection).await?;

    run_migrations(sqlite_connection).await?;
    setup_initial_admin(&container).await?;

    let app_state = AppState::new(container);
    let router = build_router(app_state);

    start_server(router).await
}

fn setup_tracing() {
    let subscriber = FmtSubscriber::builder()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new("info,rebug=trace")),
        )
        .finish();

    tracing::subscriber::set_global_default(subscriber)
        .expect("Setting default tracing subscriber failed");
}

async fn run_migrations(sqlite_connection: &Sqlite) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("Running database migrations...");
    sqlx::migrate!()
        .run(&sqlite_connection.get_pool())
        .await
        .expect("Failed to run database migrations");
    tracing::info!("Database migrations completed.");

    Ok(())
}

async fn setup_initial_admin(
    container: &ServiceContainer,
) -> Result<(), Box<dyn std::error::Error>> {
    match container
        .user_service
        .get_user_by_email(&APP_CONFIG.default_admin_email)
        .await
    {
        Ok(_) => {
            tracing::info!(
                "Default admin user with email '{}' already exists.",
                APP_CONFIG.default_admin_email
            );
        }
        Err(e) => {
            if let rebug::application::services::user_service::UserServiceError::UserNotFound = e {
                tracing::info!(
                    "Default admin user with email '{}' not found. Creating...",
                    APP_CONFIG.default_admin_email
                );
                container
                    .user_onboarding_service
                    .onboard_user(
                        &APP_CONFIG.default_admin_email,
                        &APP_CONFIG.default_admin_password,
                        Some(&APP_CONFIG.default_admin_first_name),
                        Some(&APP_CONFIG.default_admin_last_name),
                        UserRole::Admin,
                    )
                    .await
                    .map_err(|create_err| {
                        format!("Failed to create default admin user: {}", create_err)
                    })?;
                tracing::info!(
                    "Default admin user '{}' created successfully.",
                    APP_CONFIG.default_admin_email
                );
            } else {
                tracing::error!(
                    "Error checking for default admin user: {}. Admin not created.",
                    e
                );
                return Err(Box::new(e));
            }
        }
    }

    Ok(())
}

fn build_router(app_state: AppState) -> Router {
    let uploaded_files_service = ServeDir::new(&APP_CONFIG.upload_directory);

    Router::new()
        .nest("/api", get_api_routes())
        .nest_service("/uploads", uploaded_files_service)
        .merge(FrontendService::create_router().with_state(()))
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(trace::DefaultMakeSpan::new().level(Level::INFO)),
        )
        .with_state(app_state)
}

async fn start_server(router: Router) -> Result<(), Box<dyn std::error::Error>> {
    let addr = SocketAddr::from(([127, 0, 0, 1], APP_CONFIG.server_port));

    tracing::info!("Starting server on {}", addr);

    let listener = tokio::net::TcpListener::bind(&addr).await?;

    let graceful_shutdown = async {
        tokio::signal::ctrl_c()
            .await
            .expect("Failed to install CTRL+C signal handler");
        tracing::info!("Received shutdown signal, shutting down gracefully...");
    };

    axum::serve(listener, router)
        .with_graceful_shutdown(graceful_shutdown)
        .await?;

    Ok(())
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\auth.rs
File type: .rs
use axum::{
    RequestPartsExt,
    extract::FromRequestParts,
    http::{StatusCode, request::Parts},
    response::{IntoResponse, Json, Response},
};
use axum_extra::{
    TypedHeader,
    headers::{Authorization, authorization::Bearer},
};
use jsonwebtoken::{Validation, decode};
use serde_json::json;
use tracing::instrument;

use crate::{
    config::app_config::JWT_KEYS,
    domain::models::{auth::TokenClaims, user::UserRole},
};

#[derive(Debug)]
pub enum AuthError {
    MissingToken,
    InvalidToken(String),
}

impl IntoResponse for AuthError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AuthError::MissingToken => (
                StatusCode::UNAUTHORIZED,
                "Missing authentication token".to_string(),
            ),
            AuthError::InvalidToken(reason) => (
                StatusCode::UNAUTHORIZED,
                format!("Invalid token: {}", reason),
            ),
        };
        let body = Json(json!({ "error": error_message }));
        (status, body).into_response()
    }
}

#[derive(Debug, Clone)]
pub struct AuthenticatedUser {
    pub claims: TokenClaims,
}

impl<S> FromRequestParts<S> for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    #[instrument(name = "authenticate_user", skip_all, level = "debug")]
    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        tracing::debug!("Attempting to extract and validate JWT.");
        let TypedHeader(Authorization(bearer)) = parts
            .extract::<TypedHeader<Authorization<Bearer>>>()
            .await
            .map_err(|e| {
                tracing::warn!("Failed to extract Authorization header: {:?}", e);
                AuthError::MissingToken
            })?;

        let token_data =
            decode::<TokenClaims>(bearer.token(), &JWT_KEYS.decoding, &Validation::default())
                .map_err(|e| {
                    tracing::warn!("JWT decoding/validation failed: {}", e);
                    AuthError::InvalidToken(e.to_string())
                })?;

        tracing::debug!(user_id = %token_data.claims.sub, "User authenticated successfully via token.");
        Ok(AuthenticatedUser {
            claims: token_data.claims,
        })
    }
}

#[derive(Debug, Clone)]
pub struct AuthenticatedAdmin {
    pub claims: TokenClaims,
}

impl<S> FromRequestParts<S> for AuthenticatedAdmin
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    #[instrument(name = "authenticate_admin", skip_all, level = "debug")]
    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        tracing::debug!("Attempting to extract and validate admin user.");

        let AuthenticatedUser { claims } =
            AuthenticatedUser::from_request_parts(parts, state).await?;

        if claims.role == UserRole::Admin.to_string() {
            Ok(AuthenticatedAdmin { claims })
        } else {
            tracing::warn!(user_id = %claims.sub, "User is not an admin. Role found: {}. Access denied.", claims.role);
            Err(AuthError::InvalidToken(
                "User does not have admin privileges".to_string(),
            ))
        }
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\error.rs
File type: .rs
use crate::application::services::{
    auth_service::AuthServiceError, report_service::ReportServiceError,
    user_onboarding_service::UserOnboardingServiceError, user_service::UserServiceError,
};
use axum::{
    Json,
    http::StatusCode,
    response::{IntoResponse, Response},
};
use serde_json::json;

#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("Validation error: {0}")]
    Validation(String),
    #[error("Resource not found: {0}")]
    NotFound(String),
    #[error("Authentication failed")]
    Unauthorized,
    #[error("Action forbidden")]
    Forbidden,
    #[error("Conflict: {0}")]
    Conflict(String),
    #[error("Onboarding conflict: {0}")]
    OnboardingConflict(String),
    #[error("Internal server error: {0}")]
    InternalServerError(String),
}

impl From<AuthServiceError> for ApiError {
    fn from(err: AuthServiceError) -> Self {
        match err {
            AuthServiceError::InvalidCredentials => ApiError::Unauthorized,
            AuthServiceError::PasswordHashingError(msg)
            | AuthServiceError::TokenCreationError(msg)
            | AuthServiceError::InternalError(msg) => {
                tracing::error!("Internal service error: {}", msg);
                ApiError::InternalServerError("An unexpected error occurred".to_string())
            }
        }
    }
}

impl From<ReportServiceError> for ApiError {
    fn from(err: ReportServiceError) -> Self {
        match err {
            ReportServiceError::ReportNotFound { context } => ApiError::NotFound(context),
            ReportServiceError::StorageError(_) => {
                ApiError::InternalServerError("File storage failed".to_string())
            }
            ReportServiceError::RepositoryError(_) => {
                ApiError::InternalServerError("Repository error".to_string())
            }
            ReportServiceError::InternalError(msg) => ApiError::InternalServerError(msg),
        }
    }
}

impl From<UserOnboardingServiceError> for ApiError {
    fn from(err: UserOnboardingServiceError) -> Self {
        match err {
            UserOnboardingServiceError::UserAlreadyExists => {
                ApiError::OnboardingConflict("User already exists".to_string())
            }
            UserOnboardingServiceError::UserNotFound => {
                ApiError::NotFound("User not found".to_string())
            }
            UserOnboardingServiceError::BoardAlreadyExists => {
                ApiError::OnboardingConflict("Board already exists".to_string())
            }
            UserOnboardingServiceError::BoardNotFound => {
                ApiError::NotFound("Board not found".to_string())
            }
            UserOnboardingServiceError::UserCreation(msg) => {
                ApiError::Validation(format!("User creation failed: {msg}"))
            }
            UserOnboardingServiceError::BoardCreation(msg) => {
                ApiError::Validation(format!("Board creation failed: {msg}"))
            }
            UserOnboardingServiceError::InternalError(msg) => {
                tracing::error!("Internal onboarding error: {}", msg);
                ApiError::InternalServerError("An unexpected error occurred".to_string())
            }
        }
    }
}

impl From<UserServiceError> for ApiError {
    fn from(err: UserServiceError) -> Self {
        match err {
            UserServiceError::ValidationError(msg) => ApiError::Validation(msg),
            UserServiceError::UserAlreadyExists => {
                ApiError::Conflict("User already exists".to_string())
            }
            UserServiceError::UserNotFound => ApiError::NotFound("User not found".to_string()),
            UserServiceError::PasswordHashingError(msg) | UserServiceError::InternalError(msg) => {
                tracing::error!("Internal service error: {}", msg);
                ApiError::InternalServerError("An unexpected error occurred".to_string())
            }
        }
    }
}

impl ApiError {
    fn get_status_and_message(&self) -> (StatusCode, String) {
        match self {
            ApiError::Validation(msg) => (StatusCode::BAD_REQUEST, msg.clone()),
            ApiError::NotFound(msg) => (StatusCode::NOT_FOUND, msg.clone()),
            ApiError::Unauthorized => (
                StatusCode::UNAUTHORIZED,
                "Authentication failed".to_string(),
            ),
            ApiError::Forbidden => (StatusCode::FORBIDDEN, "Action forbidden".to_string()),
            ApiError::Conflict(msg) => (StatusCode::CONFLICT, msg.clone()),
            ApiError::InternalServerError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, msg.clone()),
            ApiError::OnboardingConflict(msg) => (StatusCode::CONFLICT, msg.clone()),
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, error_message) = self.get_status_and_message();

        match status {
            s if s.is_server_error() => {
                tracing::error!(status_code = %s, error.type = %self, error.message = %error_message, "API request resulted in server error");
            }
            s if s.is_client_error() => {
                tracing::warn!(status_code = %s, error.type = %self, error.message = %error_message, "API request resulted in client error");
            }
            _ => {}
        }

        let body = Json(json!({
            "error": error_message,
        }));
        (status, body).into_response()
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\mod.rs
File type: .rs
pub mod auth;
pub mod error;
pub mod models;
pub mod routers;
pub mod state;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\state.rs
File type: .rs
use std::sync::Arc;

use crate::{
    application::services::{
        auth_service::AuthServiceInterface, board_service::BoardServiceInterface,
        health_service::HealthServiceInterface, report_service::ReportServiceInterface,
        user_onboarding_service::UserOnboardingServiceInterface,
        user_service::UserServiceInterface,
    },
    infrastructure::container::service_container::ServiceContainer,
};

#[derive(Clone)]
pub struct AppState {
    container: Arc<ServiceContainer>,
}

impl AppState {
    pub fn new(container: ServiceContainer) -> Self {
        Self {
            container: Arc::new(container),
        }
    }

    pub fn health_service(&self) -> &Arc<dyn HealthServiceInterface> {
        &self.container.health_service
    }

    pub fn auth_service(&self) -> &Arc<dyn AuthServiceInterface> {
        &self.container.auth_service
    }

    pub fn user_service(&self) -> &Arc<dyn UserServiceInterface> {
        &self.container.user_service
    }

    pub fn board_service(&self) -> &Arc<dyn BoardServiceInterface> {
        &self.container.board_service
    }

    pub fn report_service(&self) -> &Arc<dyn ReportServiceInterface> {
        &self.container.report_service
    }

    pub fn user_onboarding_service(&self) -> &Arc<dyn UserOnboardingServiceInterface> {
        &self.container.user_onboarding_service
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\mod.rs
File type: .rs
pub mod request;
pub mod response;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\auth_models.rs
File type: .rs
use serde::Deserialize;
use validator::Validate;

#[derive(Deserialize, Validate)]
pub struct LoginRequest {
    #[validate(email)]
    pub email: String,
    pub password: String,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\mod.rs
File type: .rs
pub mod auth_models;
pub mod report_models;
pub mod user_models;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\report_models.rs
File type: .rs
use axum::body::Bytes;
use axum_typed_multipart::{FieldData, TryFromMultipart};
use uuid::Uuid;
use validator::Validate;

#[derive(TryFromMultipart, Validate)]
pub struct CreateScreenshotReportRequest {
    pub board_id: Uuid,
    #[validate(length(min = 1, max = 255))]
    pub title: String,
    pub description: Option<String>,
    #[validate(url)]
    pub url: Option<String>,
    pub file: FieldData<Bytes>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\user_models.rs
File type: .rs
use serde::Deserialize;
use validator::Validate;

use crate::domain::models::user::UserRole;

#[derive(Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(email)]
    pub email: String,
    #[validate(length(min = 8, message = "Password must be at least 8 characters long"))]
    pub password: String,
    #[validate(length(min = 1))]
    pub first_name: Option<String>,
    #[validate(length(min = 1))]
    pub last_name: Option<String>,
    pub role: UserRole,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\auth_models.rs
File type: .rs
use serde::Serialize;

use super::user_models::UserResponse;

#[derive(Serialize)]
pub struct LoginResponse {
    pub access_token: String,
    pub token_type: String,
    pub user: UserResponse,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\health_models.rs
File type: .rs
use serde::Serialize;

#[derive(Serialize)]
pub struct HealthResponse {
    pub status: String,
    pub message: String,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\mod.rs
File type: .rs
pub mod auth_models;
pub mod health_models;
pub mod report_models;
pub mod user_models;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\report_models.rs
File type: .rs
use serde::Serialize;
use uuid::Uuid;

#[derive(Serialize)]
pub struct ReportResponse {
    pub id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub file_path: String,
    pub url: Option<String>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\user_models.rs
File type: .rs
use serde::Serialize;
use uuid::Uuid;

use crate::domain::models::user::{User, UserRole};

#[derive(Serialize)]
pub struct UserResponse {
    pub id: Uuid,
    pub email: String,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub role: UserRole,
}

impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            email: user.email,
            first_name: user.first_name,
            last_name: user.last_name,
            role: user.role,
        }
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\auth.rs
File type: .rs
use axum::{Json, Router, extract::State, routing::post};
use tracing::instrument;
use validator::Validate;

use crate::api::{
    error::ApiError, models::request::auth_models::LoginRequest,
    models::response::auth_models::LoginResponse, state::AppState,
};

pub fn auth_routes() -> Router<AppState> {
    Router::new().route("/auth/login", post(login_handler))
}

#[instrument(skip(state, payload), fields(email = %payload.email), level = "debug")]
async fn login_handler(
    State(state): State<AppState>,
    Json(payload): Json<LoginRequest>,
) -> Result<Json<LoginResponse>, ApiError> {
    tracing::debug!("Attempting login.");
    payload.validate().map_err(|e| {
        tracing::warn!("Login validation failed: {}", e);
        ApiError::Validation(e.to_string())
    })?;

    let (user, token) = state
        .auth_service()
        .login_user(&payload.email, &payload.password)
        .await?;

    let response = LoginResponse {
        access_token: token,
        token_type: "Bearer".to_string(),
        user: user.clone().into(),
    };

    tracing::info!(user_id = %user.id, "User logged in successfully.");
    Ok(Json(response))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\health.rs
File type: .rs
use axum::{Json, Router, extract::State, http::StatusCode, routing::get};
use tracing::instrument;

use crate::api::{
    error::ApiError, models::response::health_models::HealthResponse, state::AppState,
};

pub fn health_routes() -> Router<AppState> {
    Router::new().route("/health", get(health_check_handler))
}

#[instrument(skip(state), level = "debug")]
async fn health_check_handler(
    State(state): State<AppState>,
) -> Result<(StatusCode, Json<HealthResponse>), ApiError> {
    let health_check = state.health_service().health_check();

    match health_check {
        Ok(check) => Ok((
            StatusCode::OK,
            Json(HealthResponse {
                status: check.status,
                message: check.message,
            }),
        )),
        Err(e) => {
            tracing::error!("Health check failed: {}", e);
            Err(ApiError::InternalServerError(e.to_string()))
        }
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\mod.rs
File type: .rs
use auth::auth_routes;
use axum::Router;
use health::health_routes;
use report_routes::report_routes;
use user_routes::user_routes;

use super::state::AppState;

pub mod auth;
pub mod health;
pub mod report_routes;
pub mod user_routes;

pub fn get_api_routes() -> Router<AppState> {
    Router::new()
        .merge(auth_routes())
        .merge(health_routes())
        .merge(report_routes())
        .merge(user_routes())
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\report_routes.rs
File type: .rs
use axum::{
    Json, Router,
    extract::{Path, State},
    http::StatusCode,
    routing::{get, post},
};
use axum_typed_multipart::TypedMultipart;
use tracing::instrument;
use uuid::Uuid;

use crate::{
    api::{
        auth::AuthenticatedUser,
        error::ApiError,
        models::{
            request::report_models::CreateScreenshotReportRequest,
            response::report_models::ReportResponse,
        },
        state::AppState,
    },
    domain::models::{report::CreateScreenshotReportParams, user::UserRole},
};

pub fn report_routes() -> Router<AppState> {
    let report_routes = Router::new()
        .route("/screenshots", post(create_screenshot_report_handler))
        .route("/{report_id}", get(get_report_handler));

    Router::new().nest("/reports", report_routes)
}

#[instrument(skip(state, authenticated_user), fields(user_id = %authenticated_user.claims.sub, report_id = %report_id), level = "debug")]
async fn get_report_handler(
    State(state): State<AppState>,
    authenticated_user: AuthenticatedUser,
    Path(report_id): Path<Uuid>,
) -> Result<(StatusCode, Json<ReportResponse>), ApiError> {
    tracing::debug!("Fetching report with ID: {}", report_id);

    let report = state.report_service().get_report(report_id).await?;

    if report.user_id != authenticated_user.claims.sub
        && authenticated_user.claims.role != UserRole::Admin.to_string()
    {
        return Err(ApiError::Forbidden);
    }

    let response = ReportResponse {
        id: report.id,
        title: report.title,
        description: report.description,
        file_path: report.file_path,
        url: report.url,
    };

    tracing::info!(report_id = %report.id, "Report fetched successfully.");

    Ok((StatusCode::OK, Json(response)))
}

#[instrument(skip(state, authenticated_user, payload), fields(user_id = %authenticated_user.claims.sub), level = "debug")]
async fn create_screenshot_report_handler(
    State(state): State<AppState>,
    authenticated_user: AuthenticatedUser,
    TypedMultipart(payload): TypedMultipart<CreateScreenshotReportRequest>,
) -> Result<(StatusCode, Json<ReportResponse>), ApiError> {
    tracing::debug!("Creating screenshot report.");

    let file_name = payload.file.metadata.file_name.ok_or_else(|| {
        ApiError::Validation("File name is required in the multipart data.".to_string())
    })?;

    let params = CreateScreenshotReportParams {
        user_id: authenticated_user.claims.sub,
        board_id: payload.board_id,
        title: payload.title,
        description: payload.description,
        original_file_name: file_name,
        file_data: payload.file.contents,
        url: payload.url,
    };

    let report = state
        .report_service()
        .create_screenshot_report(params)
        .await
        .map_err(|e| {
            tracing::error!("Report service error: {:?}", e);
            ApiError::from(e)
        })?;

    let response = ReportResponse {
        id: report.id,
        title: report.title,
        description: report.description,
        file_path: report.file_path,
        url: report.url,
    };

    tracing::info!(report_id = %report.id, "Screenshot report created successfully.");

    Ok((StatusCode::CREATED, Json(response)))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\user_routes.rs
File type: .rs
use axum::{
    Json, Router,
    extract::State,
    http::StatusCode,
    routing::{get, post},
};
use tracing::instrument;
use validator::Validate;

use crate::api::{
    auth::{AuthenticatedAdmin, AuthenticatedUser},
    error::ApiError,
    models::{request::user_models::CreateUserRequest, response::user_models::UserResponse},
    state::AppState,
};

pub fn user_routes() -> Router<AppState> {
    let user_routes = Router::new()
        .route("/", post(create_user_handler))
        .route("/me", get(get_current_user_handler));

    Router::new().nest("/users", user_routes)
}

#[instrument(skip(state, payload, authenticated_admin), fields(admin_id = %authenticated_admin.claims.sub), level = "debug")]
async fn create_user_handler(
    State(state): State<AppState>,
    authenticated_admin: AuthenticatedAdmin,
    Json(payload): Json<CreateUserRequest>,
) -> Result<(StatusCode, Json<UserResponse>), ApiError> {
    tracing::debug!("Creating user.");

    payload.validate().map_err(|e| {
        tracing::warn!("User validation failed: {}", e);
        ApiError::Validation(e.to_string())
    })?;

    let user = state
        .user_onboarding_service()
        .onboard_user(
            &payload.email,
            &payload.password,
            payload.first_name.as_deref(),
            payload.last_name.as_deref(),
            payload.role,
        )
        .await?;

    tracing::info!(user_id = %user.id, "User created successfully.");

    Ok((StatusCode::CREATED, Json(user.into())))
}

#[instrument(skip(state, authenticated_user), fields(user_id = %authenticated_user.claims.sub), level = "debug")]
async fn get_current_user_handler(
    State(state): State<AppState>,
    authenticated_user: AuthenticatedUser,
) -> Result<Json<UserResponse>, ApiError> {
    tracing::debug!("Fetching current user.");
    let user_id = authenticated_user.claims.sub;

    let user = state.user_service().get_user_by_id(user_id).await?;

    Ok(Json(user.into()))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\mod.rs
File type: .rs
pub mod services;


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\auth_service.rs
File type: .rs
use std::sync::Arc;

use async_trait::async_trait;
use chrono::{Duration, Utc};
use jsonwebtoken::{Header, encode};
use tracing::instrument;
use uuid::Uuid;

use crate::{
    config::app_config::{APP_CONFIG, JWT_KEYS},
    domain::models::{
        auth::TokenClaims,
        user::{User, UserRole},
    },
    infrastructure::security::password_hasher::{PasswordError, verify_password},
};

use super::user_service::UserServiceInterface;

#[derive(Debug, thiserror::Error)]
pub enum AuthServiceError {
    #[error("Failed to create JWT: {0}")]
    TokenCreationError(String),
    #[error("Invalid credentials")]
    InvalidCredentials,
    #[error("Password hashing failed: {0}")]
    PasswordHashingError(String),
    #[error("Internal server error: {0}")]
    InternalError(String),
}

impl From<PasswordError> for AuthServiceError {
    fn from(err: PasswordError) -> Self {
        match err {
            PasswordError::HashingError(msg) | PasswordError::VerificationError(msg) => {
                AuthServiceError::PasswordHashingError(msg)
            }
            PasswordError::InvalidPassword => AuthServiceError::InvalidCredentials,
        }
    }
}

pub type AuthServiceResult<T> = Result<T, AuthServiceError>;

#[async_trait]
pub trait AuthServiceInterface: Send + Sync {
    async fn login_user(&self, email: &str, password: &str) -> AuthServiceResult<(User, String)>;
}

#[derive(Clone)]
pub struct AuthService {
    user_service: Arc<dyn UserServiceInterface>,
}

impl AuthService {
    pub fn new(user_service: Arc<dyn UserServiceInterface>) -> Self {
        Self { user_service }
    }

    #[instrument(skip(self), fields(user_id = %user_id, role = %role), level = "debug")]
    fn create_jwt(&self, user_id: Uuid, role: &UserRole) -> Result<String, AuthServiceError> {
        tracing::debug!("Creating JWT for user.");

        let now = Utc::now();
        let iat = now.timestamp() as usize;
        let exp = (now + Duration::seconds(APP_CONFIG.jwt_expiration_seconds)).timestamp() as usize;

        let claims = TokenClaims {
            sub: user_id,
            role: role.to_string(),
            exp,
            iat,
        };

        encode(&Header::default(), &claims, &JWT_KEYS.encoding).map_err(|e| {
            AuthServiceError::TokenCreationError(format!("Failed to create JWT: {}", e))
        })
    }
}

#[async_trait]
impl AuthServiceInterface for AuthService {
    #[instrument(skip(self, password), level = "debug")]
    async fn login_user(&self, email: &str, password: &str) -> AuthServiceResult<(User, String)> {
        tracing::debug!("Attempting to authenticate user.");

        let user = self
            .user_service
            .get_user_by_email(email)
            .await
            .map_err(|_| {
                tracing::warn!(
                    "Authentication failed: user not found or other error during lookup."
                );
                AuthServiceError::InvalidCredentials
            })?;

        if verify_password(password, &user.password_hash)? {
            tracing::debug!(user_id = %user.id, "Password verification successful.");
            let token = self.create_jwt(user.id, &user.role)?;
            Ok((user, token))
        } else {
            tracing::warn!(user_id = %user.id, "Password verification failed.");
            Err(AuthServiceError::InvalidCredentials)
        }
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\board_service.rs
File type: .rs
use std::sync::Arc;

use async_trait::async_trait;
use tracing::instrument;
use uuid::Uuid;

use crate::domain::{
    models::board::Board,
    repositories::{RepositoryError, board_repository::BoardRepository},
};

#[derive(Debug, thiserror::Error)]
pub enum BoardServiceError {
    #[error("Validation error: {0}")]
    ValidationError(String),
    #[error("Board already exists")]
    BoardAlreadyExists,
    #[error("Board not found")]
    BoardNotFound,
    #[error("Access denied")]
    AccessDenied,
    #[error("Internal server error: {0}")]
    InternalError(String),
}

impl From<RepositoryError> for BoardServiceError {
    fn from(err: RepositoryError) -> Self {
        match err {
            RepositoryError::NotFound => BoardServiceError::BoardNotFound,
            RepositoryError::AlreadyExists => BoardServiceError::BoardAlreadyExists,
            RepositoryError::DatabaseError(msg) => BoardServiceError::InternalError(msg),
        }
    }
}

pub type BoardServiceResult<T> = Result<T, BoardServiceError>;

#[async_trait]
pub trait BoardServiceInterface: Send + Sync {
    async fn create_board(
        &self,
        name: &str,
        description: Option<&str>,
        owner_id: Uuid,
        is_default: bool,
    ) -> BoardServiceResult<Board>;

    async fn get_board_by_id(&self, board_id: Uuid) -> BoardServiceResult<Board>;
    async fn get_boards_by_user_id(&self, user_id: Uuid) -> BoardServiceResult<Vec<Board>>;

    async fn ensure_user_can_access_board(
        &self,
        user_id: Uuid,
        board_id: Uuid,
    ) -> BoardServiceResult<bool>;
}

#[derive(Clone)]
pub struct BoardService {
    board_repository: Arc<dyn BoardRepository>,
}

impl BoardService {
    pub fn new(board_repository: Arc<dyn BoardRepository>) -> Self {
        Self { board_repository }
    }
}

#[async_trait]
impl BoardServiceInterface for BoardService {
    #[instrument(skip(self, description), fields(owner_id, board_name = %name), level = "info")]
    async fn create_board(
        &self,
        name: &str,
        description: Option<&str>,
        owner_id: Uuid,
        is_default: bool,
    ) -> BoardServiceResult<Board> {
        if name.is_empty() {
            return Err(BoardServiceError::ValidationError(
                "Board name cannot be empty".to_string(),
            ));
        }

        let board = self
            .board_repository
            .create_board(name, description, owner_id, is_default)
            .await?;

        tracing::info!(board_id = %board.id,"Board created successfully");
        Ok(board)
    }

    #[instrument(skip(self), fields(board_id = %board_id), level = "debug")]
    async fn get_board_by_id(&self, board_id: Uuid) -> BoardServiceResult<Board> {
        self.board_repository
            .find_by_id(board_id)
            .await?
            .ok_or(BoardServiceError::BoardNotFound)
    }

    #[instrument(skip(self), fields(user_id = %user_id), level = "debug")]
    async fn get_boards_by_user_id(&self, user_id: Uuid) -> BoardServiceResult<Vec<Board>> {
        let boards = self.board_repository.find_by_user_id(user_id).await?;

        if boards.is_empty() {
            Err(BoardServiceError::BoardNotFound)
        } else {
            Ok(boards)
        }
    }

    #[instrument(skip(self), fields(user_id = %user_id), level = "debug")]
    async fn ensure_user_can_access_board(
        &self,
        user_id: Uuid,
        board_id: Uuid,
    ) -> BoardServiceResult<bool> {
        let board = self.get_board_by_id(board_id).await?;

        if board.owner_id == user_id {
            Ok(true)
        } else {
            Err(BoardServiceError::AccessDenied)
        }
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\health_service.rs
File type: .rs
use async_trait::async_trait;

use crate::domain::models::health::HealthCheck;

pub type HealthServiceResult<T> = Result<T, Box<dyn std::error::Error>>;

#[async_trait]
pub trait HealthServiceInterface: Send + Sync {
    fn health_check(&self) -> HealthServiceResult<HealthCheck>;
}

#[derive(Clone)]
pub struct HealthService;

impl HealthService {
    pub fn new() -> Self {
        HealthService
    }
}

impl Default for HealthService {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl HealthServiceInterface for HealthService {
    fn health_check(&self) -> HealthServiceResult<HealthCheck> {
        Ok(HealthCheck {
            status: "success".to_string(),
            message: "Everything is OK".to_string(),
        })
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\mod.rs
File type: .rs
pub mod auth_service;
pub mod board_service;
pub mod health_service;
pub mod report_service;
pub mod user_onboarding_service;
pub mod user_service;


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\report_service.rs
File type: .rs
use async_trait::async_trait;
use std::sync::Arc;
use tracing::instrument;
use uuid::Uuid;

use crate::domain::{
    models::report::{CreateReportParams, CreateScreenshotReportParams, Report, ReportType},
    ports::storage_port::{StorageError, StoragePort},
    repositories::{RepositoryError, report_repository::ReportRepository},
};

use super::board_service::{BoardServiceError, BoardServiceInterface};

#[derive(Debug, thiserror::Error)]
pub enum ReportServiceError {
    #[error("Repository error: {0}")]
    RepositoryError(#[from] RepositoryError),
    #[error("Storage error: {0}")]
    StorageError(#[from] StorageError),
    #[error("Report not found: {context}")]
    ReportNotFound { context: String },
    #[error("Internal server error: {0}")]
    InternalError(String),
}

impl From<BoardServiceError> for ReportServiceError {
    fn from(err: BoardServiceError) -> Self {
        match err {
            BoardServiceError::ValidationError(msg) => ReportServiceError::InternalError(msg),
            BoardServiceError::BoardAlreadyExists => {
                ReportServiceError::InternalError("Board already exists".to_string())
            }
            BoardServiceError::BoardNotFound => {
                ReportServiceError::InternalError("Board not found".to_string())
            }
            BoardServiceError::AccessDenied => {
                ReportServiceError::InternalError("Access denied".to_string())
            }
            BoardServiceError::InternalError(msg) => ReportServiceError::InternalError(msg),
        }
    }
}

pub type ReportServiceResult<T> = Result<T, ReportServiceError>;

#[async_trait]
pub trait ReportServiceInterface: Send + Sync {
    async fn create_screenshot_report(
        &self,
        params: CreateScreenshotReportParams,
    ) -> ReportServiceResult<Report>;

    async fn get_report(&self, id: Uuid) -> ReportServiceResult<Report>;
}

#[derive(Clone)]
pub struct ReportService {
    report_repository: Arc<dyn ReportRepository>,
    storage_port: Arc<dyn StoragePort>,

    board_service: Arc<dyn BoardServiceInterface>,
}

impl ReportService {
    pub fn new(
        report_repository: Arc<dyn ReportRepository>,
        storage_port: Arc<dyn StoragePort>,
        board_service: Arc<dyn BoardServiceInterface>,
    ) -> Self {
        Self {
            report_repository,
            storage_port,
            board_service,
        }
    }
}

#[async_trait]
impl ReportServiceInterface for ReportService {
    #[instrument(skip(self, params), fields(user_id = %params.user_id), board_id= %params.board_id, level="info")]
    async fn create_screenshot_report(
        &self,
        params: CreateScreenshotReportParams,
    ) -> ReportServiceResult<Report> {
        self.board_service
            .ensure_user_can_access_board(params.user_id, params.board_id)
            .await?;

        tracing::debug!("Saving file to storage");
        let file_path = self
            .storage_port
            .save_file(&params.original_file_name, params.file_data)
            .await?;

        tracing::debug!("Saving report");
        let create_params = CreateReportParams {
            user_id: params.user_id,
            board_id: params.board_id,
            title: params.title,
            report_type: ReportType::Screenshot,
            description: params.description,
            file_path,
            url: params.url,
        };

        let report = self.report_repository.create_report(create_params).await?;

        tracing::info!(report_id = %report.id, "Screenshot report created successfully");
        Ok(report)
    }

    #[instrument(skip(self), fields(report_id = %id), level="info")]
    async fn get_report(&self, id: Uuid) -> ReportServiceResult<Report> {
        tracing::debug!("Fetching report with ID: {}", id);

        let report = self
            .report_repository
            .get_report(id)
            .await?
            .ok_or_else(|| ReportServiceError::ReportNotFound {
                context: format!("Failed to fetch report with ID: {}", id),
            })?;

        tracing::info!(report_id = %report.id, "Report fetched successfully");
        Ok(report)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\user_onboarding_service.rs
File type: .rs
use super::{
    board_service::{BoardServiceError, BoardServiceInterface},
    user_service::{UserServiceError, UserServiceInterface},
};
use crate::domain::models::user::{User, UserRole};
use async_trait::async_trait;
use std::sync::Arc;
use tracing::instrument;

#[derive(Debug, thiserror::Error)]
pub enum UserOnboardingServiceError {
    #[error("User already exists")]
    UserAlreadyExists,
    #[error("User not found")]
    UserNotFound,
    #[error("Board already exists")]
    BoardAlreadyExists,
    #[error("Board not found")]
    BoardNotFound,
    #[error("User creation failed: {0}")]
    UserCreation(String),
    #[error("Board creation failed: {0}")]
    BoardCreation(String),
    #[error("Internal server error: {0}")]
    InternalError(String),
}

pub type UserOnboardingServiceResult<T> = Result<T, UserOnboardingServiceError>;

#[async_trait]
pub trait UserOnboardingServiceInterface: Send + Sync {
    async fn onboard_user(
        &self,
        email: &str,
        password: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        user_role: UserRole,
    ) -> UserOnboardingServiceResult<User>;
}

impl From<UserServiceError> for UserOnboardingServiceError {
    fn from(err: UserServiceError) -> Self {
        match err {
            UserServiceError::ValidationError(msg)
            | UserServiceError::PasswordHashingError(msg) => {
                UserOnboardingServiceError::UserCreation(msg)
            }
            UserServiceError::UserAlreadyExists => UserOnboardingServiceError::UserAlreadyExists,
            UserServiceError::UserNotFound => UserOnboardingServiceError::UserNotFound,
            UserServiceError::InternalError(msg) => UserOnboardingServiceError::InternalError(msg),
        }
    }
}

impl From<BoardServiceError> for UserOnboardingServiceError {
    fn from(err: BoardServiceError) -> Self {
        match err {
            BoardServiceError::ValidationError(msg) => {
                UserOnboardingServiceError::BoardCreation(msg)
            }
            BoardServiceError::BoardAlreadyExists => UserOnboardingServiceError::BoardAlreadyExists,
            BoardServiceError::BoardNotFound => UserOnboardingServiceError::BoardNotFound,
            BoardServiceError::AccessDenied => {
                UserOnboardingServiceError::InternalError("user could not access board".to_string())
            }
            BoardServiceError::InternalError(msg) => UserOnboardingServiceError::InternalError(msg),
        }
    }
}

pub struct UserOnboardingService {
    user_service: Arc<dyn UserServiceInterface>,
    board_service: Arc<dyn BoardServiceInterface>,
}

impl UserOnboardingService {
    pub fn new(
        user_service: Arc<dyn UserServiceInterface>,
        board_service: Arc<dyn BoardServiceInterface>,
    ) -> Self {
        Self {
            user_service,
            board_service,
        }
    }
}

#[async_trait]
impl UserOnboardingServiceInterface for UserOnboardingService {
    #[instrument(
        skip(self, email, password),
        fields(email = %email, first_name = ?first_name, last_name = ?last_name),
        level = "info"
    )]
    async fn onboard_user(
        &self,
        email: &str,
        password: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        user_role: UserRole,
    ) -> UserOnboardingServiceResult<User> {
        let user = self
            .user_service
            .create_user(email, password, first_name, last_name, user_role)
            .await?;

        let board_name = format!(
            "{}'s Board",
            user.first_name.clone().unwrap_or("User".to_string())
        );

        self.board_service
            .create_board(&board_name, Some("User's default board"), user.id, true)
            .await?;

        Ok(user)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\user_service.rs
File type: .rs
use std::sync::Arc;

use async_trait::async_trait;
use tracing::instrument;
use uuid::Uuid;

use crate::{
    domain::{
        models::user::{User, UserRole},
        repositories::{RepositoryError, user_repository::UserRepository},
    },
    infrastructure::security::password_hasher::{PasswordError, hash_password},
};

use super::board_service::BoardServiceError;

#[derive(Debug, thiserror::Error)]
pub enum UserServiceError {
    #[error("Validation error: {0}")]
    ValidationError(String),
    #[error("User already exists")]
    UserAlreadyExists,
    #[error("User not found")]
    UserNotFound,
    #[error("Password hashing failed: {0}")]
    PasswordHashingError(String),
    #[error("Internal server error: {0}")]
    InternalError(String),
}

impl From<RepositoryError> for UserServiceError {
    fn from(err: RepositoryError) -> Self {
        match err {
            RepositoryError::NotFound => UserServiceError::UserNotFound,
            RepositoryError::AlreadyExists => UserServiceError::UserAlreadyExists,
            RepositoryError::DatabaseError(msg) => UserServiceError::InternalError(msg),
        }
    }
}

impl From<PasswordError> for UserServiceError {
    fn from(err: PasswordError) -> Self {
        match err {
            PasswordError::HashingError(msg) | PasswordError::VerificationError(msg) => {
                UserServiceError::PasswordHashingError(msg)
            }
            _ => UserServiceError::InternalError("Unexpected error".to_string()),
        }
    }
}

impl From<BoardServiceError> for UserServiceError {
    fn from(err: BoardServiceError) -> Self {
        match err {
            BoardServiceError::ValidationError(msg) => UserServiceError::ValidationError(msg),
            BoardServiceError::BoardAlreadyExists => {
                UserServiceError::InternalError("Board already exists".to_string())
            }
            BoardServiceError::BoardNotFound => {
                UserServiceError::InternalError("Board not found".to_string())
            }
            BoardServiceError::AccessDenied => {
                UserServiceError::InternalError("Access denied".to_string())
            }
            BoardServiceError::InternalError(msg) => UserServiceError::InternalError(msg),
        }
    }
}

pub type UserServiceResult<T> = Result<T, UserServiceError>;

#[async_trait]
pub trait UserServiceInterface: Send + Sync {
    async fn create_user(
        &self,
        email: &str,
        password: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        user_role: UserRole,
    ) -> UserServiceResult<User>;

    async fn get_user_by_id(&self, user_id: Uuid) -> UserServiceResult<User>;
    async fn get_user_by_email(&self, email: &str) -> UserServiceResult<User>;
}

#[derive(Clone)]
pub struct UserService {
    user_repository: Arc<dyn UserRepository>,
}

impl UserService {
    pub fn new(user_repository: Arc<dyn UserRepository>) -> Self {
        Self { user_repository }
    }
}

#[async_trait]
impl UserServiceInterface for UserService {
    #[instrument(skip(self, password), fields(email = %email, first_name = ?first_name, last_name = ?last_name), level = "info")]
    async fn create_user(
        &self,
        email: &str,
        password: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        user_role: UserRole,
    ) -> UserServiceResult<User> {
        tracing::debug!("Validating user input.");

        if email.is_empty() || !email.contains('@') {
            return Err(UserServiceError::ValidationError(
                "Invalid email format".to_string(),
            ));
        }
        if password.len() < 8 {
            return Err(UserServiceError::ValidationError(
                "Password must be at least 8 characters long".to_string(),
            ));
        }

        tracing::debug!("Hashing password.");
        let password_hash = hash_password(password)?;

        tracing::debug!("Attempting to save user to repository.");
        let user = self
            .user_repository
            .create_user(email, &password_hash, first_name, last_name, user_role)
            .await
            .map_err(UserServiceError::from)?;

        tracing::info!(user_id = %user.id, "User created successfully.");
        Ok(user)
    }

    #[instrument(skip(self), level = "debug")]
    async fn get_user_by_id(&self, user_id: Uuid) -> UserServiceResult<User> {
        self.user_repository
            .find_by_id(user_id)
            .await?
            .ok_or(UserServiceError::UserNotFound)
    }

    #[instrument(skip(self), level = "debug")]
    async fn get_user_by_email(&self, email: &str) -> UserServiceResult<User> {
        self.user_repository
            .find_by_email(email)
            .await?
            .ok_or(UserServiceError::UserNotFound)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/config\app_config.rs
File type: .rs
use config::{Config, Environment, File};
use jsonwebtoken::{DecodingKey, EncodingKey};
use once_cell::sync::Lazy;
use serde::Deserialize;

#[derive(Debug, Deserialize, Clone)]
pub struct AppConfig {
    pub server_port: u16,
    pub database_url: String,
    pub upload_directory: String,
    pub file_base_url: String,
    pub frontend_directory: String,
    pub jwt_secret: String,
    pub jwt_expiration_seconds: i64,
    pub default_admin_email: String,
    pub default_admin_password: String,
    pub default_admin_first_name: String,
    pub default_admin_last_name: String,
}

impl AppConfig {
    pub fn init() -> Result<Self, config::ConfigError> {
        tracing::info!("Initializing configuration...");
        let s = Config::builder()
            .add_source(File::with_name("config/default").required(false))
            .add_source(Environment::with_prefix("REBUG"))
            .build()?;

        s.try_deserialize().map_err(|e| {
            tracing::error!("Failed to deserialize configuration: {:?}", e);
            config::ConfigError::Message("Failed to deserialize configuration".into())
        })
    }
}

pub static APP_CONFIG: Lazy<AppConfig> =
    Lazy::new(|| AppConfig::init().expect("Failed to initialize configuration"));

pub struct Keys {
    pub encoding: EncodingKey,
    pub decoding: DecodingKey,
}

impl Keys {
    fn new(secret: &[u8]) -> Self {
        Self {
            encoding: EncodingKey::from_secret(secret),
            decoding: DecodingKey::from_secret(secret),
        }
    }
}

pub static JWT_KEYS: Lazy<Keys> = Lazy::new(|| Keys::new(APP_CONFIG.jwt_secret.as_bytes()));


--------------------------------------------------
File End
--------------------------------------------------


./src/config\mod.rs
File type: .rs
pub mod app_config;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\mod.rs
File type: .rs
pub mod models;
pub mod ports;
pub mod repositories;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\auth.rs
File type: .rs
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenClaims {
    pub sub: Uuid,    // Subject (user_id)
    pub role: String, // User role (can be UserRole enum if you stringify it)
    pub exp: usize,   // Expiration timestamp (seconds since Unix epoch)
    pub iat: usize,   // Issued at timestamp
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\board.rs
File type: .rs
use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Board {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub owner_id: Uuid,
    pub is_default: bool,
    #[sqlx(default)]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[sqlx(default)]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\health.rs
File type: .rs
#[derive(Debug, Clone)]
pub struct HealthCheck {
    pub status: String,
    pub message: String,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\mod.rs
File type: .rs
pub mod auth;
pub mod board;
pub mod health;
pub mod report;
pub mod user;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\report.rs
File type: .rs
use std::fmt;

use bytes::Bytes;
use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, sqlx::Type)]
#[sqlx(type_name = "TEXT", rename_all = "PascalCase")]
pub enum ReportType {
    Screenshot,
    Video,
}

impl fmt::Display for ReportType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ReportType::Screenshot => write!(f, "Screenshot"),
            ReportType::Video => write!(f, "Video"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Report {
    pub id: Uuid,
    pub user_id: Uuid,
    pub board_id: Uuid,
    pub report_type: ReportType,
    pub title: String,
    pub description: Option<String>,
    pub file_path: String,
    pub url: Option<String>,
    #[sqlx(default)]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[sqlx(default)]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct CreateReportParams {
    pub user_id: Uuid,
    pub board_id: Uuid,
    pub title: String,
    pub report_type: ReportType,
    pub description: Option<String>,
    pub file_path: String,
    pub url: Option<String>,
}

#[derive(Debug, Clone)]
pub struct CreateScreenshotReportParams {
    pub user_id: Uuid,
    pub board_id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub url: Option<String>,
    pub original_file_name: String,
    pub file_data: Bytes,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\user.rs
File type: .rs
use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use std::fmt;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, sqlx::Type)]
#[sqlx(type_name = "TEXT", rename_all = "PascalCase")]
pub enum UserRole {
    Admin,
    User,
}

impl fmt::Display for UserRole {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            UserRole::Admin => write!(f, "Admin"),
            UserRole::User => write!(f, "User"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub password_hash: String,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub role: UserRole,
    #[sqlx(default)]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[sqlx(default)]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\ports\mod.rs
File type: .rs
pub mod storage_port;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\ports\storage_port.rs
File type: .rs
use async_trait::async_trait;
use bytes::Bytes;

#[derive(Debug, thiserror::Error)]
pub enum StorageError {
    #[error("Validation error: {0}")]
    ValidationError(String),
    #[error("Failed to save file: {0}")]
    SaveFailed(String),
    #[error("Failed to retrieve file: {0}")]
    RetrievalFailed(String),
    #[error("File not found")]
    NotFound,
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),
}

pub type StorageResult<T> = Result<T, StorageError>;

#[async_trait]
pub trait StoragePort: Send + Sync {
    /// Saves file data and returns a unique identifier or path to the stored file.
    async fn save_file(&self, file_name: &str, data: Bytes) -> StorageResult<String>;

    // Potentially add other methods like:
    // async fn retrieve_file(&self, file_identifier: &str) -> StorageResult<Bytes>;
    // async fn delete_file(&self, file_identifier: &str) -> StorageResult<()>;
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\repositories\board_repository.rs
File type: .rs
use uuid::Uuid;

use crate::domain::models::board::Board;

use super::RepositoryResult;

#[async_trait::async_trait]
pub trait BoardRepository: Send + Sync {
    async fn create_board(
        &self,
        name: &str,
        description: Option<&str>,
        owner_id: Uuid,
        is_default: bool,
    ) -> RepositoryResult<Board>;

    async fn find_by_id(&self, id: Uuid) -> RepositoryResult<Option<Board>>;
    async fn find_by_user_id(&self, user_id: Uuid) -> RepositoryResult<Vec<Board>>;
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\repositories\mod.rs
File type: .rs
use sqlx::Error as SqlxError;

pub mod board_repository;
pub mod report_repository;
pub mod user_repository;

#[derive(Debug, thiserror::Error)]
pub enum RepositoryError {
    #[error("User not found")]
    NotFound,
    #[error("User already exists")]
    AlreadyExists,
    #[error("Database error: {0}")]
    DatabaseError(String),
}

pub fn map_sqlx_error(e: SqlxError) -> RepositoryError {
    match e {
        SqlxError::RowNotFound => RepositoryError::NotFound,
        SqlxError::Database(db_err) => {
            if db_err.is_unique_violation() {
                RepositoryError::AlreadyExists
            } else {
                RepositoryError::DatabaseError(db_err.to_string())
            }
        }
        _ => RepositoryError::DatabaseError(e.to_string()),
    }
}

pub type RepositoryResult<T> = Result<T, RepositoryError>;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\repositories\report_repository.rs
File type: .rs
use async_trait::async_trait;
use uuid::Uuid;

use crate::domain::models::report::{CreateReportParams, Report};

use super::RepositoryResult;

#[async_trait]
pub trait ReportRepository: Send + Sync {
    async fn create_report(&self, params: CreateReportParams) -> RepositoryResult<Report>;

    async fn get_report(&self, id: Uuid) -> RepositoryResult<Option<Report>>;
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\repositories\user_repository.rs
File type: .rs
use uuid::Uuid;

use crate::domain::models::user::{User, UserRole};

use super::RepositoryResult;

#[async_trait::async_trait]
pub trait UserRepository: Send + Sync {
    async fn create_user(
        &self,
        email: &str,
        password_hash: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        role: UserRole,
    ) -> RepositoryResult<User>;

    async fn find_by_email(&self, email: &str) -> RepositoryResult<Option<User>>;
    async fn find_by_id(&self, id: Uuid) -> RepositoryResult<Option<User>>;
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\mod.rs
File type: .rs
pub mod container;
pub mod database;
pub mod frontend;
pub mod repositories;
pub mod security;
pub mod storage;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\container\mod.rs
File type: .rs
pub mod service_container;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\container\service_container.rs
File type: .rs
use std::sync::Arc;

use crate::{
    application::services::{
        auth_service::{AuthService, AuthServiceInterface},
        board_service::{BoardService, BoardServiceInterface},
        health_service::{HealthService, HealthServiceInterface},
        report_service::{ReportService, ReportServiceInterface},
        user_onboarding_service::{UserOnboardingService, UserOnboardingServiceInterface},
        user_service::{UserService, UserServiceInterface},
    },
    config::app_config::APP_CONFIG,
    domain::ports::storage_port::StoragePort,
    infrastructure::{
        database::sqlite::Sqlite,
        repositories::{
            sqlite_board_repository::SqliteBoardRepository,
            sqlite_report_repository::SqliteReportRepository,
            sqlite_user_repository::SqliteUserRepository,
        },
        storage::file_system_storage::FileSystemStorage,
    },
};

pub struct ServiceContainer {
    pub health_service: Arc<dyn HealthServiceInterface>,
    pub auth_service: Arc<dyn AuthServiceInterface>,
    pub user_service: Arc<dyn UserServiceInterface>,
    pub board_service: Arc<dyn BoardServiceInterface>,
    pub report_service: Arc<dyn ReportServiceInterface>,
    pub user_onboarding_service: Arc<dyn UserOnboardingServiceInterface>,
}

impl ServiceContainer {
    pub async fn new(sqlite_connection: &Sqlite) -> Result<Self, Box<dyn std::error::Error>> {
        // Repository layer
        let user_repository = Arc::new(SqliteUserRepository::new(sqlite_connection.get_pool()));
        let board_repository = Arc::new(SqliteBoardRepository::new(sqlite_connection.get_pool()));
        let report_repository = Arc::new(SqliteReportRepository::new(sqlite_connection.get_pool()));

        // Storage layer
        let storage_port: Arc<dyn StoragePort> = Arc::new(FileSystemStorage::new(
            APP_CONFIG.upload_directory.clone(),
            APP_CONFIG.file_base_url.clone(),
        )?);

        // Service layer
        let health_service = Arc::new(HealthService::new());
        let user_service = Arc::new(UserService::new(user_repository));
        let board_service = Arc::new(BoardService::new(board_repository));
        let auth_service = Arc::new(AuthService::new(user_service.clone()));
        let report_service = Arc::new(ReportService::new(
            report_repository,
            storage_port,
            board_service.clone(),
        ));
        let user_onboarding_service = Arc::new(UserOnboardingService::new(
            user_service.clone(),
            board_service.clone(),
        ));

        Ok(Self {
            health_service,
            auth_service,
            user_service,
            board_service,
            report_service,
            user_onboarding_service,
        })
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\database\mod.rs
File type: .rs
pub mod sqlite;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\database\sqlite.rs
File type: .rs
use sqlx::SqlitePool;

#[derive(Clone)]
pub struct Sqlite {
    pool: SqlitePool,
}

impl Sqlite {
    pub async fn new(database_url: String) -> Result<Self, Box<dyn std::error::Error>> {
        let db_pool = SqlitePool::connect(&database_url)
            .await
            .expect("Failed to create SQLite connection pool");

        Ok(Self { pool: db_pool })
    }

    pub fn get_pool(&self) -> SqlitePool {
        self.pool.clone()
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\frontend\frontend_service.rs
File type: .rs
use crate::config::app_config::APP_CONFIG;
use axum::Router;
use std::path::Path;
use tower_http::services::{ServeDir, ServeFile};

pub struct FrontendService;

impl FrontendService {
    pub fn create_router() -> Router {
        let frontend_dir = Path::new(&APP_CONFIG.frontend_directory);

        if !frontend_dir.exists() {
            tracing::warn!(
                "Frontend directory '{}' does not exist. Frontend serving disabled.",
                APP_CONFIG.frontend_directory
            );
            return Router::new();
        }

        let index_file_path = frontend_dir.join("index.html");

        if !index_file_path.exists() {
            tracing::warn!("Frontend index.html not found. Frontend serving disabled.");
            return Router::new();
        }

        let serve_dir = ServeDir::new(&APP_CONFIG.frontend_directory)
            .not_found_service(ServeFile::new(index_file_path));

        Router::new().fallback_service(serve_dir)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\frontend\mod.rs
File type: .rs
pub mod frontend_service;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\repositories\mod.rs
File type: .rs
pub mod sqlite_board_repository;
pub mod sqlite_report_repository;
pub mod sqlite_user_repository;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\repositories\sqlite_board_repository.rs
File type: .rs
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use sqlx::SqlitePool;
use tracing::instrument;
use uuid::Uuid;

use crate::domain::{
    models::board::Board,
    repositories::{RepositoryResult, board_repository::BoardRepository, map_sqlx_error},
};

#[derive(Clone)]
pub struct SqliteBoardRepository {
    pool: SqlitePool,
}

impl SqliteBoardRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl BoardRepository for SqliteBoardRepository {
    #[instrument(skip(self), level = "debug")]
    async fn create_board(
        &self,
        name: &str,
        description: Option<&str>,
        owner_id: Uuid,
        is_default: bool,
    ) -> RepositoryResult<Board> {
        let board_id = Uuid::new_v4();
        tracing::debug!(board_id = %board_id, "Creating new board.");

        sqlx::query_as!(
            Board,
            r#"
            INSERT INTO boards (id, name, description, owner_id, is_default)
            VALUES (?, ?, ?, ?, ?)
             RETURNING 
                id as "id: uuid::Uuid",
                owner_id as "owner_id: uuid::Uuid",
                name,
                description,
                is_default as "is_default: bool",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            "#,
            board_id,
            name,
            description,
            owner_id,
            is_default
        )
        .fetch_one(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }

    #[instrument(skip(self), level = "debug")]
    async fn find_by_id(&self, id: Uuid) -> RepositoryResult<Option<Board>> {
        sqlx::query_as!(
            Board,
            r#"
            SELECT 
                id as "id: uuid::Uuid",
                owner_id as "owner_id: uuid::Uuid",
                name,
                description,
                is_default as "is_default: bool",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM boards
            WHERE id = ?
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }

    #[instrument(skip(self), level = "debug")]
    async fn find_by_user_id(&self, user_id: Uuid) -> RepositoryResult<Vec<Board>> {
        sqlx::query_as!(
            Board,
            r#"
            SELECT 
                id as "id: uuid::Uuid",
                owner_id as "owner_id: uuid::Uuid",
                name,
                description,
                is_default as "is_default: bool",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM boards
            WHERE owner_id = ?
            "#,
            user_id
        )
        .fetch_all(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\repositories\sqlite_report_repository.rs
File type: .rs
use async_trait::async_trait;

use chrono::{DateTime, Utc};
use sqlx::SqlitePool;
use uuid::Uuid;

use crate::domain::{
    models::report::{CreateReportParams, Report, ReportType},
    repositories::{RepositoryResult, map_sqlx_error, report_repository::ReportRepository},
};

#[derive(Clone)]
pub struct SqliteReportRepository {
    pool: SqlitePool,
}

impl SqliteReportRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl ReportRepository for SqliteReportRepository {
    async fn create_report(&self, params: CreateReportParams) -> RepositoryResult<Report> {
        let report_id = Uuid::new_v4();

        let result = sqlx::query_as!(
            Report,
            r#"
            INSERT INTO reports (id, user_id, board_id, report_type, title, description, file_path, url)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            RETURNING
                id as "id: uuid::Uuid",
                user_id as "user_id: uuid::Uuid",
                board_id as "board_id: uuid::Uuid",
                report_type as "report_type: ReportType",
                title,
                description,
                file_path,
                url,
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            "#,
            report_id,
            params.user_id,
            params.board_id,
            params.report_type,
            params.title,
            params.description,
            params.file_path,
            params.url,
        )
        .fetch_one(&self.pool)
        .await;

        match result {
            Ok(report) => Ok(report),
            Err(e) => Err(map_sqlx_error(e)),
        }
    }

    async fn get_report(&self, id: Uuid) -> RepositoryResult<Option<Report>> {
        sqlx::query_as!(
            Report,
            r#"
            SELECT 
                id as "id: uuid::Uuid",
                user_id as "user_id: uuid::Uuid",
                board_id as "board_id: uuid::Uuid",
                report_type as "report_type: ReportType",
                title,
                description,
                file_path,
                url,
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM reports
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\repositories\sqlite_user_repository.rs
File type: .rs
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use sqlx::SqlitePool;
use tracing::instrument;
use uuid::Uuid;

use crate::domain::{
    models::user::{User, UserRole},
    repositories::{RepositoryResult, map_sqlx_error, user_repository::UserRepository},
};

#[derive(Clone)]
pub struct SqliteUserRepository {
    pool: SqlitePool,
}

impl SqliteUserRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for SqliteUserRepository {
    #[instrument(skip(self, password_hash), fields(email = %email, role = %role), level = "debug")]
    async fn create_user(
        &self,
        email: &str,
        password_hash: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        role: UserRole,
    ) -> RepositoryResult<User> {
        let user_id = Uuid::new_v4();
        tracing::debug!(user_id = %user_id, "Executing insert query for new user.");

        sqlx::query_as!(
            User,
            r#"
            INSERT INTO users (id, email, password_hash, first_name, last_name, role)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING
                id as "id: uuid::Uuid",
                email,
                password_hash,
                first_name,
                last_name,
                role as "role: UserRole",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            "#,
            user_id,
            email,
            password_hash,
            first_name,
            last_name,
            role
        )
        .fetch_one(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }

    #[instrument(skip(self), fields(email = %email), level = "debug")]
    async fn find_by_email(&self, email: &str) -> RepositoryResult<Option<User>> {
        sqlx::query_as!(
            User,
            r#"
            SELECT
                id as "id: uuid::Uuid",
                email,
                password_hash,
                first_name,
                last_name,
                role as "role: UserRole",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM users
            WHERE email = $1
            "#,
            email
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }

    #[instrument(skip(self), fields(id = %id), level = "debug")]
    async fn find_by_id(&self, id: Uuid) -> RepositoryResult<Option<User>> {
        sqlx::query_as!(
            User,
            r#"
            SELECT
                id as "id: uuid::Uuid",
                email,
                password_hash,
                first_name,
                last_name,
                role as "role: UserRole",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM users
            WHERE id = $1 
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\security\mod.rs
File type: .rs
pub mod password_hasher;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\security\password_hasher.rs
File type: .rs
use bcrypt::{DEFAULT_COST, hash, verify};

#[derive(Debug, thiserror::Error)]
pub enum PasswordError {
    #[error("Failed to hash password: {0}")]
    HashingError(String),
    #[error("Failed to verify password: {0}")]
    VerificationError(String),
    #[error("Invalid password")]
    InvalidPassword,
}

pub type PasswordResult<T> = Result<T, PasswordError>;

pub fn hash_password(password: &str) -> PasswordResult<String> {
    hash(password, DEFAULT_COST).map_err(|e| PasswordError::HashingError(e.to_string()))
}

pub fn verify_password(password: &str, hashed_password: &str) -> PasswordResult<bool> {
    verify(password, hashed_password).map_err(|e| PasswordError::VerificationError(e.to_string()))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\storage\file_system_storage.rs
File type: .rs
use async_trait::async_trait;
use bytes::Bytes;
use chrono::Utc;
use std::path::Path;
use tokio::fs;
use tracing::instrument;

use crate::domain::ports::storage_port::{StorageError, StoragePort, StorageResult};

#[derive(Clone)]
pub struct FileSystemStorage {
    upload_directory: String,
    base_url: String,
}

impl FileSystemStorage {
    const MAX_FILE_SIZE: usize = 50 * 1024 * 1024; // 50MB
    const ALLOWED_EXTENSIONS: &'static [&'static str] = &["png"];

    pub fn new(upload_directory: String, base_url: String) -> StorageResult<Self> {
        let path = Path::new(&upload_directory);
        if !path.exists() {
            std::fs::create_dir_all(path).map_err(|e| {
                StorageError::ConfigurationError(format!(
                    "Failed to create upload directory '{}': {}",
                    upload_directory, e
                ))
            })?;
        }

        Ok(Self {
            upload_directory,
            base_url,
        })
    }

    fn validate_file(&self, file_name: &str, data: &Bytes) -> StorageResult<()> {
        if data.len() > Self::MAX_FILE_SIZE {
            return Err(StorageError::ValidationError("File too large".to_string()));
        }

        let extension = self.get_file_extension(file_name)?;

        if !Self::ALLOWED_EXTENSIONS.contains(&extension.to_lowercase().as_str()) {
            return Err(StorageError::ValidationError(
                format!("Invalid file type: '{}'", extension).to_string(),
            ));
        }

        Ok(())
    }

    fn get_file_extension(&self, file_name: &str) -> Result<String, StorageError> {
        Path::new(file_name)
            .extension()
            .and_then(|ext| ext.to_str())
            .map(|s| s.to_string())
            .ok_or_else(|| StorageError::ValidationError("File extension not found".to_string()))
    }

    fn get_public_url(&self, file_path: &str) -> String {
        format!("{}/{}", self.base_url, file_path)
    }
}

#[async_trait]
impl StoragePort for FileSystemStorage {
    #[instrument(skip(self, data), fields(original_file_name = %original_file_name, file_size = data.len()), level = "debug")]
    async fn save_file(&self, original_file_name: &str, data: Bytes) -> StorageResult<String> {
        self.validate_file(original_file_name, &data)?;

        let unique_file_name = format!(
            "{}.{}",
            Utc::now().timestamp_millis(),
            self.get_file_extension(original_file_name)?
        );

        let full_path = Path::new(&self.upload_directory).join(&unique_file_name);

        tracing::debug!(path = %full_path.display(), "Attempting to write file to disk.");
        fs::write(&full_path, data)
            .await
            .map_err(|e| StorageError::SaveFailed(e.to_string()))?;
        tracing::debug!(path = %full_path.display(), "File saved successfully.");

        Ok(self.get_public_url(&unique_file_name))
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\storage\mod.rs
File type: .rs
pub mod file_system_storage;


--------------------------------------------------
File End
--------------------------------------------------
