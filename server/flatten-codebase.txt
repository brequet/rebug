Folder Structure
--------------------------------------------------
/
    lib.rs
    main.rs
api/
    auth.rs
    error.rs
    mod.rs
    state.rs
    models/
        mod.rs
        request/
            auth_models.rs
            mod.rs
            report_models.rs
            user_models.rs
        response/
            auth_models.rs
            mod.rs
            report_models.rs
            user_models.rs
    routers/
        auth.rs
        health.rs
        mod.rs
        report_routes.rs
        user_routes.rs
application/
    mod.rs
    services/
        auth_service.rs
        health_service.rs
        mod.rs
        report_service.rs
        user_service.rs
config/
    app_config.rs
    mod.rs
domain/
    mod.rs
    models/
        auth.rs
        mod.rs
        report.rs
        user.rs
    ports/
        mod.rs
        storage_port.rs
    repositories/
        mod.rs
        report_repository.rs
        user_repository.rs
infrastructure/
    mod.rs
    database/
        mod.rs
        sqlite.rs
    repositories/
        mod.rs
        sqlite_report_repository.rs
        sqlite_user_repository.rs
    security/
        mod.rs
        password_hasher.rs
    storage/
        file_system_storage.rs
        mod.rs


File Contents
--------------------------------------------------


./src/lib.rs
File type: .rs
pub mod api;
pub mod application;
pub mod config;
pub mod domain;
pub mod infrastructure;


--------------------------------------------------
File End
--------------------------------------------------


./src/main.rs
File type: .rs
use std::{env, net::SocketAddr, sync::Arc};

use axum::Router;
use dotenv::dotenv;
use rebug::{
    api::{routers::get_api_routes, state::AppState},
    application::services::{
        auth_service::AuthService, health_service::HealthService, report_service::ReportService,
        user_service::UserService,
    },
    domain::ports::storage_port::StoragePort,
    infrastructure::{
        database::sqlite::Sqlite,
        repositories::{
            sqlite_report_repository::SqliteReportRepository,
            sqlite_user_repository::SqliteUserRepository,
        },
        storage::file_system_storage::FileSystemStorage,
    },
};
use tower_http::trace::{self, TraceLayer};
use tracing::{Level, info};
use tracing_subscriber::{EnvFilter, FmtSubscriber};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv().ok();

    let subscriber = FmtSubscriber::builder()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new("info,rebug=trace")),
        )
        .finish();

    tracing::subscriber::set_global_default(subscriber)
        .expect("Setting default tracing subscriber failed");

    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set in .env file");
    let sqlite_connection = Sqlite::new(database_url.clone())
        .await
        .expect("Failed to create SQLite connection pool");

    info!("Running database migrations...");
    sqlx::migrate!()
        .run(&sqlite_connection.get_pool())
        .await
        .expect("Failed to run database migrations");
    info!("Database migrations completed.");

    let upload_dir = env::var("UPLOAD_DIRECTORY").unwrap_or_else(|_| "uploads".to_string());
    let file_system_storage = Arc::new(
        FileSystemStorage::new(upload_dir).expect("Failed to initialize file system storage"),
    );
    let storage_port: Arc<dyn StoragePort> = file_system_storage;

    let health_service = Arc::new(HealthService);

    let user_repository = Arc::new(SqliteUserRepository::new(sqlite_connection.get_pool()));
    let user_service = Arc::new(UserService::new(user_repository));

    let auth_service = Arc::new(AuthService::new(user_service.clone()));

    let report_repository = Arc::new(SqliteReportRepository::new(sqlite_connection.get_pool()));
    let report_service = Arc::new(ReportService::new(report_repository, storage_port));

    let app_state = AppState::new(auth_service, health_service, report_service, user_service);

    let router = Router::new()
        .nest("/api", get_api_routes())
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(trace::DefaultMakeSpan::new().level(Level::INFO)),
        )
        .with_state(app_state);

    let port: u16 = env::var("PORT")
        .unwrap_or_else(|_| "3000".to_string())
        .parse::<u16>()?;
    let addr = SocketAddr::from(([127, 0, 0, 1], port));

    info!("Starting server on {}", addr);

    let listener = tokio::net::TcpListener::bind(&addr).await?;
    axum::serve(listener, router).await?;

    Ok(())
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\auth.rs
File type: .rs
use axum::{
    RequestPartsExt,
    extract::FromRequestParts,
    http::{StatusCode, request::Parts},
    response::{IntoResponse, Json, Response},
};
use axum_extra::{
    TypedHeader,
    headers::{Authorization, authorization::Bearer},
};
use jsonwebtoken::{Validation, decode};
use serde_json::json;

use crate::{config::app_config::JWT_KEYS, domain::models::auth::TokenClaims};

#[derive(Debug)]
pub enum AuthError {
    MissingToken,
    InvalidToken(String),
}

impl IntoResponse for AuthError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AuthError::MissingToken => (
                StatusCode::UNAUTHORIZED,
                "Missing authentication token".to_string(),
            ),
            AuthError::InvalidToken(reason) => (
                StatusCode::UNAUTHORIZED,
                format!("Invalid token: {}", reason),
            ),
        };
        let body = Json(json!({ "error": error_message }));
        (status, body).into_response()
    }
}

#[derive(Debug, Clone)]
pub struct AuthenticatedUser {
    pub claims: TokenClaims,
}

impl<S> FromRequestParts<S> for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        let TypedHeader(Authorization(bearer)) = parts
            .extract::<TypedHeader<Authorization<Bearer>>>()
            .await
            .map_err(|_| AuthError::MissingToken)?;

        let token_data =
            decode::<TokenClaims>(bearer.token(), &JWT_KEYS.decoding, &Validation::default())
                .map_err(|e| AuthError::InvalidToken(e.to_string()))?;

        Ok(AuthenticatedUser {
            claims: token_data.claims,
        })
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\error.rs
File type: .rs
use crate::application::services::{
    auth_service::AuthServiceError, user_service::UserServiceError,
};
use axum::{
    Json,
    http::StatusCode,
    response::{IntoResponse, Response},
};
use serde_json::json;

#[derive(Debug, thiserror::Error)]
pub enum ApiError {
    #[error("Validation error: {0}")]
    Validation(String),
    #[error("Resource not found: {0}")]
    NotFound(String),
    #[error("Authentication failed")]
    Unauthorized,
    #[error("Action forbidden")]
    Forbidden,
    #[error("Conflict: {0}")]
    Conflict(String),
    #[error("Internal server error: {0}")]
    InternalServerError(String),
}

impl From<AuthServiceError> for ApiError {
    fn from(err: AuthServiceError) -> Self {
        match err {
            AuthServiceError::InvalidCredentials => ApiError::Unauthorized,
            AuthServiceError::PasswordHashingError(msg)
            | AuthServiceError::TokenCreationError(msg)
            | AuthServiceError::InternalError(msg) => {
                tracing::error!("Internal service error: {}", msg);
                ApiError::InternalServerError("An unexpected error occurred".to_string())
            }
        }
    }
}

impl From<UserServiceError> for ApiError {
    fn from(err: UserServiceError) -> Self {
        match err {
            UserServiceError::ValidationError(msg) => ApiError::Validation(msg),
            UserServiceError::UserAlreadyExists => {
                ApiError::Conflict("User already exists".to_string())
            }
            UserServiceError::UserNotFound => ApiError::NotFound("User not found".to_string()),
            UserServiceError::PasswordHashingError(msg) | UserServiceError::InternalError(msg) => {
                tracing::error!("Internal service error: {}", msg);
                ApiError::InternalServerError("An unexpected error occurred".to_string())
            }
        }
    }
}

impl ApiError {
    fn get_status_and_message(&self) -> (StatusCode, String) {
        match self {
            ApiError::Validation(msg) => (StatusCode::BAD_REQUEST, msg.clone()),
            ApiError::NotFound(msg) => (StatusCode::NOT_FOUND, msg.clone()),
            ApiError::Unauthorized => (
                StatusCode::UNAUTHORIZED,
                "Authentication failed".to_string(),
            ),
            ApiError::Forbidden => (StatusCode::FORBIDDEN, "Action forbidden".to_string()),
            ApiError::Conflict(msg) => (StatusCode::CONFLICT, msg.clone()),
            ApiError::InternalServerError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, msg.clone()),
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, error_message) = self.get_status_and_message();

        match status {
            s if s.is_server_error() => {
                tracing::error!(status_code = %s, error.type = %self, error.message = %error_message, "API request resulted in server error");
            }
            s if s.is_client_error() => {
                tracing::warn!(status_code = %s, error.type = %self, error.message = %error_message, "API request resulted in client error");
            }
            _ => {}
        }

        let body = Json(json!({
            "error": error_message,
        }));
        (status, body).into_response()
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\mod.rs
File type: .rs
pub mod auth;
pub mod error;
pub mod models;
pub mod routers;
pub mod state;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\state.rs
File type: .rs
use std::sync::Arc;

use crate::application::services::{
    auth_service::AuthService, health_service::HealthService, report_service::ReportService,
    user_service::UserService,
};

#[derive(Clone)]
pub struct AppState {
    pub auth_service: Arc<AuthService>,
    pub health_service: Arc<HealthService>,
    pub report_service: Arc<ReportService>,
    pub user_service: Arc<UserService>,
}

impl AppState {
    pub fn new(
        auth_service: Arc<AuthService>,
        health_service: Arc<HealthService>,
        report_service: Arc<ReportService>,
        user_service: Arc<UserService>,
    ) -> Self {
        AppState {
            auth_service,
            health_service,
            report_service,
            user_service,
        }
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\mod.rs
File type: .rs
pub mod request;
pub mod response;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\auth_models.rs
File type: .rs
use serde::Deserialize;
use validator::Validate;

#[derive(Deserialize, Validate)]
pub struct LoginRequest {
    #[validate(email)]
    pub email: String,
    pub password: String,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\mod.rs
File type: .rs
pub mod auth_models;
pub mod report_models;
pub mod user_models;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\report_models.rs
File type: .rs
use axum::body::Bytes;
use axum_typed_multipart::{FieldData, TryFromMultipart};

#[derive(TryFromMultipart)]
pub struct CreateScreenshotReportRequest {
    // Regular form fields
    pub title: String,
    pub description: Option<String>,
    pub url: Option<String>,

    // File field
    pub file: FieldData<Bytes>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\request\user_models.rs
File type: .rs
use serde::Deserialize;
use validator::Validate;

#[derive(Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(email)]
    pub email: String,
    #[validate(length(min = 8, message = "Password must be at least 8 characters long"))]
    pub password: String,
    #[validate(length(min = 1))]
    pub first_name: Option<String>,
    #[validate(length(min = 1))]
    pub last_name: Option<String>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\auth_models.rs
File type: .rs
use serde::Serialize;

use super::user_models::UserResponse;

#[derive(Serialize)]
pub struct LoginResponse {
    pub access_token: String,
    pub token_type: String,
    pub user: UserResponse,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\mod.rs
File type: .rs
pub mod auth_models;
pub mod report_models;
pub mod user_models;


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\report_models.rs
File type: .rs
use serde::Serialize;
use uuid::Uuid;

#[derive(Serialize)]
pub struct ReportResponse {
    pub id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub file_path: String,
    pub url: Option<String>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\models\response\user_models.rs
File type: .rs
use serde::Serialize;
use uuid::Uuid;

use crate::domain::models::user::{User, UserRole};

#[derive(Serialize)]
pub struct UserResponse {
    pub id: Uuid,
    pub email: String,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub role: UserRole,
}

impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            email: user.email,
            first_name: user.first_name,
            last_name: user.last_name,
            role: user.role,
        }
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\auth.rs
File type: .rs
use axum::{Json, Router, extract::State, routing::post};
use validator::Validate;

use crate::api::{
    error::ApiError, models::request::auth_models::LoginRequest,
    models::response::auth_models::LoginResponse, state::AppState,
};

pub fn auth_routes() -> Router<AppState> {
    Router::new().route("/auth/login", post(login_handler))
}

async fn login_handler(
    State(state): State<AppState>,
    Json(payload): Json<LoginRequest>,
) -> Result<Json<LoginResponse>, ApiError> {
    payload
        .validate()
        .map_err(|e| ApiError::Validation(e.to_string()))?;

    let (user, token) = state
        .auth_service
        .login_user(&payload.email, &payload.password)
        .await?;

    let response = LoginResponse {
        access_token: token,
        token_type: "Bearer".to_string(),
        user: user.into(),
    };

    Ok(Json(response))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\health.rs
File type: .rs
use axum::{Json, Router, extract::State, response::IntoResponse, routing::get};

use crate::api::state::AppState;

pub fn health_routes() -> Router<AppState> {
    Router::new().route("/health", get(health_check_handler))
}

async fn health_check_handler(State(state): State<AppState>) -> impl IntoResponse {
    let response = state.health_service.health_check();
    Json(response)
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\mod.rs
File type: .rs
use auth::auth_routes;
use axum::Router;
use health::health_routes;
use report_routes::report_routes;
use user_routes::user_routes;

use super::state::AppState;

pub mod auth;
pub mod health;
pub mod report_routes;
pub mod user_routes;

pub fn get_api_routes() -> Router<AppState> {
    Router::new()
        .merge(auth_routes())
        .merge(health_routes())
        .merge(report_routes())
        .merge(user_routes())
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\report_routes.rs
File type: .rs
use axum::{Json, Router, extract::State, http::StatusCode, routing::post};
use axum_typed_multipart::TypedMultipart;

use crate::api::{
    auth::AuthenticatedUser,
    error::ApiError,
    models::{
        request::report_models::CreateScreenshotReportRequest,
        response::report_models::ReportResponse,
    },
    state::AppState,
};

pub fn report_routes() -> Router<AppState> {
    Router::new().route(
        "/reports/screenshots",
        post(create_screenshot_report_handler),
    )
    // TODO: getters for reports
}

async fn create_screenshot_report_handler(
    State(state): State<AppState>,
    authenticated_user: AuthenticatedUser,
    TypedMultipart(payload): TypedMultipart<CreateScreenshotReportRequest>,
) -> Result<(StatusCode, Json<ReportResponse>), ApiError> {
    let user_id = authenticated_user.claims.sub;

    let title = payload.title;
    let description = payload.description;
    let url = payload.url;

    let file_name = payload.file.metadata.file_name.ok_or_else(|| {
        ApiError::Validation("File name is required in the multipart data.".to_string())
    })?;
    let file_data = payload.file.contents;

    let report = state
        .report_service
        .create_screenshot_report(user_id, &file_name, file_data, title, description, url)
        .await
        .map_err(|e| {
            tracing::error!("Report service error: {:?}", e);
            ApiError::InternalServerError("Failed to create report.".to_string())
        })?;

    let response = ReportResponse {
        id: report.id,
        title: report.title,
        description: report.description,
        file_path: report.file_path,
        url: report.url,
    };

    Ok((StatusCode::CREATED, Json(response)))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/api\routers\user_routes.rs
File type: .rs
use axum::{
    Json, Router,
    extract::State,
    http::StatusCode,
    routing::{get, post},
};
use validator::Validate;

use crate::api::{
    auth::AuthenticatedUser,
    error::ApiError,
    models::{request::user_models::CreateUserRequest, response::user_models::UserResponse},
    state::AppState,
};

pub fn user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", post(create_user_handler))
        .route("/users/me", get(get_current_user_handler))
}

// TODO: create default admin user
// TODO: check admin role
async fn create_user_handler(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<(StatusCode, Json<UserResponse>), ApiError> {
    payload
        .validate()
        .map_err(|e| ApiError::Validation(e.to_string()))?;

    let user = state
        .user_service
        .create_user(
            &payload.email,
            &payload.password,
            payload.first_name.as_deref(),
            payload.last_name.as_deref(),
        )
        .await?;

    Ok((StatusCode::CREATED, Json(user.into())))
}

async fn get_current_user_handler(
    State(state): State<AppState>,
    authenticated_user: AuthenticatedUser,
) -> Result<Json<UserResponse>, ApiError> {
    let user_id = authenticated_user.claims.sub;

    let user = state.user_service.get_user_by_id(user_id).await?;

    Ok(Json(user.into()))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\mod.rs
File type: .rs
pub mod services;


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\auth_service.rs
File type: .rs
use std::sync::Arc;

use chrono::{Duration, Utc};
use jsonwebtoken::{Header, encode};
use uuid::Uuid;

use crate::{
    config::app_config::{JWT_CONFIG, JWT_KEYS},
    domain::models::{
        auth::TokenClaims,
        user::{User, UserRole},
    },
    infrastructure::security::password_hasher::{PasswordError, verify_password},
};

use super::user_service::UserService;

#[derive(Debug, thiserror::Error)]
pub enum AuthServiceError {
    #[error("Failed to create JWT: {0}")]
    TokenCreationError(String),
    #[error("Invalid credentials")]
    InvalidCredentials,
    #[error("Password hashing failed: {0}")]
    PasswordHashingError(String),
    #[error("Internal server error: {0}")]
    InternalError(String),
}

impl From<PasswordError> for AuthServiceError {
    fn from(err: PasswordError) -> Self {
        match err {
            PasswordError::HashingError(msg) | PasswordError::VerificationError(msg) => {
                AuthServiceError::PasswordHashingError(msg)
            }
            PasswordError::InvalidPassword => AuthServiceError::InvalidCredentials,
        }
    }
}

pub type AuthServiceResult<T> = Result<T, AuthServiceError>;

#[derive(Clone)]
pub struct AuthService {
    user_service: Arc<UserService>,
}

impl AuthService {
    pub fn new(user_service: Arc<UserService>) -> Self {
        Self { user_service }
    }

    pub async fn login_user(
        &self,
        email: &str,
        password: &str,
    ) -> AuthServiceResult<(User, String)> {
        let user = self
            .user_service
            .get_user_by_email(email)
            .await
            .map_err(|_| AuthServiceError::InvalidCredentials)?;

        if verify_password(password, &user.password_hash)? {
            let token = self.create_jwt(user.id, &user.role)?;
            Ok((user, token))
        } else {
            Err(AuthServiceError::InvalidCredentials)
        }
    }

    fn create_jwt(&self, user_id: Uuid, role: &UserRole) -> Result<String, AuthServiceError> {
        let now = Utc::now();
        let iat = now.timestamp() as usize;
        let exp = (now + Duration::seconds(JWT_CONFIG.expiration_seconds)).timestamp() as usize;

        let claims = TokenClaims {
            sub: user_id,
            role: role.to_string(),
            exp,
            iat,
        };

        encode(&Header::default(), &claims, &JWT_KEYS.encoding).map_err(|e| {
            AuthServiceError::TokenCreationError(format!("Failed to create JWT: {}", e))
        })
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\health_service.rs
File type: .rs
#[derive(Clone)]
pub struct HealthService;

impl HealthService {
    pub fn new() -> Self {
        HealthService
    }

    pub fn health_check(&self) -> serde_json::Value {
        const HEALTH_CHECK_RESPONSE: &str = "Everything is OK";

        let json_response = serde_json::json!({
            "status": "success",
            "message": HEALTH_CHECK_RESPONSE,
        });

        json_response
    }
}

impl Default for HealthService {
    fn default() -> Self {
        Self::new()
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\mod.rs
File type: .rs
pub mod auth_service;
pub mod health_service;
pub mod report_service;
pub mod user_service;


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\report_service.rs
File type: .rs
use bytes::Bytes;
use std::sync::Arc;
use uuid::Uuid;

use crate::domain::{
    models::report::{Report, ReportType},
    ports::storage_port::{StorageError, StoragePort},
    repositories::{RepositoryError, report_repository::ReportRepository},
};

#[derive(Debug, thiserror::Error)]
pub enum ReportServiceError {
    #[error("Repository error: {0}")]
    RepositoryError(#[from] RepositoryError),
    #[error("Storage error: {0}")]
    StorageError(#[from] StorageError),
    #[error("Internal server error: {0}")]
    InternalError(String),
}

pub type ReportServiceResult<T> = Result<T, ReportServiceError>;

#[derive(Clone)]
pub struct ReportService {
    report_repository: Arc<dyn ReportRepository>,
    storage_port: Arc<dyn StoragePort>,
}

impl ReportService {
    pub fn new(
        report_repository: Arc<dyn ReportRepository>,
        storage_port: Arc<dyn StoragePort>,
    ) -> Self {
        Self {
            report_repository,
            storage_port,
        }
    }

    pub async fn create_screenshot_report(
        &self,
        user_id: Uuid,
        original_file_name: &str,
        file_data: Bytes,
        title: String,
        description: Option<String>,
        url: Option<String>,
    ) -> ReportServiceResult<Report> {
        let file_path = self
            .storage_port
            .save_file(original_file_name, file_data)
            .await?;

        let report = self
            .report_repository
            .create_report(
                user_id,
                title,
                ReportType::Screenshot,
                description,
                file_path,
                url,
            )
            .await?;
        Ok(report)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/application\services\user_service.rs
File type: .rs
use std::sync::Arc;

use uuid::Uuid;

use crate::{
    domain::{
        models::user::{User, UserRole},
        repositories::{RepositoryError, user_repository::UserRepository},
    },
    infrastructure::security::password_hasher::{PasswordError, hash_password},
};

#[derive(Debug, thiserror::Error)]
pub enum UserServiceError {
    #[error("Validation error: {0}")]
    ValidationError(String),
    #[error("User already exists")]
    UserAlreadyExists,
    #[error("User not found")]
    UserNotFound,
    #[error("Password hashing failed: {0}")]
    PasswordHashingError(String),
    #[error("Internal server error: {0}")]
    InternalError(String),
}

impl From<RepositoryError> for UserServiceError {
    fn from(err: RepositoryError) -> Self {
        match err {
            RepositoryError::NotFound => UserServiceError::UserNotFound,
            RepositoryError::AlreadyExists => UserServiceError::UserAlreadyExists,
            RepositoryError::DatabaseError(msg) => UserServiceError::InternalError(msg),
        }
    }
}

impl From<PasswordError> for UserServiceError {
    fn from(err: PasswordError) -> Self {
        match err {
            PasswordError::HashingError(msg) | PasswordError::VerificationError(msg) => {
                UserServiceError::PasswordHashingError(msg)
            }
            _ => UserServiceError::InternalError("Unexpected error".to_string()),
        }
    }
}

pub type UserServiceResult<T> = Result<T, UserServiceError>;

#[derive(Clone)]
pub struct UserService {
    user_repository: Arc<dyn UserRepository>,
}

impl UserService {
    pub fn new(user_repository: Arc<dyn UserRepository>) -> Self {
        Self { user_repository }
    }

    pub async fn create_user(
        &self,
        email: &str,
        password: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
    ) -> UserServiceResult<User> {
        tracing::info!(email = %email, "Creating user...");

        if email.is_empty() || !email.contains('@') {
            return Err(UserServiceError::ValidationError(
                "Invalid email format".to_string(),
            ));
        }
        if password.len() < 8 {
            return Err(UserServiceError::ValidationError(
                "Password must be at least 8 characters long".to_string(),
            ));
        }

        let password_hash = hash_password(password)?;

        let user = self
            .user_repository
            .create_user(email, &password_hash, first_name, last_name, UserRole::User)
            .await
            .map_err(UserServiceError::from)?;

        tracing::info!(user_id = %user.id, "User created successfully.");
        Ok(user)
    }

    pub async fn get_user_by_id(&self, user_id: Uuid) -> UserServiceResult<User> {
        self.user_repository
            .find_by_id(user_id)
            .await?
            .ok_or(UserServiceError::UserNotFound)
    }

    pub async fn get_user_by_email(&self, email: &str) -> UserServiceResult<User> {
        self.user_repository
            .find_by_email(email)
            .await?
            .ok_or(UserServiceError::UserNotFound)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/config\app_config.rs
File type: .rs
use once_cell::sync::Lazy;
use std::env;

pub struct JwtConfig {
    pub secret: String,
    pub expiration_seconds: i64,
}

impl JwtConfig {
    fn init() -> Self {
        let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
        let expiration_seconds = env::var("JWT_EXPIRATION_SECONDS")
            .expect("JWT_EXPIRATION_SECONDS must be set")
            .parse::<i64>()
            .expect("JWT_EXPIRATION_SECONDS must be a number");
        Self {
            secret,
            expiration_seconds,
        }
    }
}

pub static JWT_CONFIG: Lazy<JwtConfig> = Lazy::new(JwtConfig::init);

use jsonwebtoken::{DecodingKey, EncodingKey};

pub struct Keys {
    pub encoding: EncodingKey,
    pub decoding: DecodingKey,
}

impl Keys {
    fn new(secret: &[u8]) -> Self {
        Self {
            encoding: EncodingKey::from_secret(secret),
            decoding: DecodingKey::from_secret(secret),
        }
    }
}

pub static JWT_KEYS: Lazy<Keys> = Lazy::new(|| Keys::new(JWT_CONFIG.secret.as_bytes()));


--------------------------------------------------
File End
--------------------------------------------------


./src/config\mod.rs
File type: .rs
pub mod app_config;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\mod.rs
File type: .rs
pub mod models;
pub mod ports;
pub mod repositories;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\auth.rs
File type: .rs
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenClaims {
    pub sub: Uuid,    // Subject (user_id)
    pub role: String, // User role (can be UserRole enum if you stringify it)
    pub exp: usize,   // Expiration timestamp (seconds since Unix epoch)
    pub iat: usize,   // Issued at timestamp
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\mod.rs
File type: .rs
pub mod auth;
pub mod report;
pub mod user;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\report.rs
File type: .rs
use std::fmt;

use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, sqlx::Type)]
#[sqlx(type_name = "TEXT", rename_all = "PascalCase")]
pub enum ReportType {
    Screenshot,
    Video,
}

impl fmt::Display for ReportType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ReportType::Screenshot => write!(f, "Screenshot"),
            ReportType::Video => write!(f, "Video"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Report {
    pub id: Uuid,
    pub user_id: Uuid,
    pub report_type: ReportType,
    pub title: String,
    pub description: Option<String>,
    pub file_path: String, // Path to the stored file
    pub url: Option<String>,
    #[sqlx(default)]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[sqlx(default)]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\models\user.rs
File type: .rs
use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use std::fmt;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, sqlx::Type)]
#[sqlx(type_name = "TEXT", rename_all = "PascalCase")]
pub enum UserRole {
    Admin,
    User,
}

impl fmt::Display for UserRole {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            UserRole::Admin => write!(f, "Admin"),
            UserRole::User => write!(f, "User"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub password_hash: String,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub role: UserRole,
    #[sqlx(default)]
    pub created_at: chrono::DateTime<chrono::Utc>,
    #[sqlx(default)]
    pub updated_at: chrono::DateTime<chrono::Utc>,
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\ports\mod.rs
File type: .rs
pub mod storage_port;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\ports\storage_port.rs
File type: .rs
use async_trait::async_trait;
use bytes::Bytes;

#[derive(Debug, thiserror::Error)]
pub enum StorageError {
    #[error("Failed to save file: {0}")]
    SaveFailed(String),
    #[error("Failed to retrieve file: {0}")]
    RetrievalFailed(String),
    #[error("File not found")]
    NotFound,
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),
}

pub type StorageResult<T> = Result<T, StorageError>;

#[async_trait]
pub trait StoragePort: Send + Sync {
    /// Saves file data and returns a unique identifier or path to the stored file.
    async fn save_file(&self, file_name: &str, data: Bytes) -> StorageResult<String>;
    // Potentially add other methods like:
    // async fn retrieve_file(&self, file_identifier: &str) -> StorageResult<Bytes>;
    // async fn delete_file(&self, file_identifier: &str) -> StorageResult<()>;
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\repositories\mod.rs
File type: .rs
use sqlx::Error as SqlxError;

pub mod report_repository;
pub mod user_repository;

#[derive(Debug, thiserror::Error)]
pub enum RepositoryError {
    #[error("User not found")]
    NotFound,
    #[error("User already exists")]
    AlreadyExists,
    #[error("Database error: {0}")]
    DatabaseError(String),
}

pub fn map_sqlx_error(e: SqlxError) -> RepositoryError {
    match e {
        SqlxError::RowNotFound => RepositoryError::NotFound,
        SqlxError::Database(db_err) => {
            if db_err.is_unique_violation() {
                RepositoryError::AlreadyExists
            } else {
                RepositoryError::DatabaseError(db_err.to_string())
            }
        }
        _ => RepositoryError::DatabaseError(e.to_string()),
    }
}

pub type RepositoryResult<T> = Result<T, RepositoryError>;


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\repositories\report_repository.rs
File type: .rs
use async_trait::async_trait;
use uuid::Uuid;

use crate::domain::models::report::{Report, ReportType};

use super::RepositoryResult;

#[async_trait]
pub trait ReportRepository: Send + Sync {
    async fn create_report(
        &self,
        user_id: Uuid,
        title: String,
        report_type: ReportType,
        description: Option<String>,
        file_path: String,
        url: Option<String>,
    ) -> RepositoryResult<Report>;
    async fn get_report(&self, id: Uuid) -> RepositoryResult<Option<Report>>;
}


--------------------------------------------------
File End
--------------------------------------------------


./src/domain\repositories\user_repository.rs
File type: .rs
use uuid::Uuid;

use crate::domain::models::user::{User, UserRole};

use super::RepositoryResult;

#[async_trait::async_trait]
pub trait UserRepository: Send + Sync {
    async fn create_user(
        &self,
        email: &str,
        password_hash: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        role: UserRole,
    ) -> RepositoryResult<User>;

    async fn find_by_email(&self, email: &str) -> RepositoryResult<Option<User>>;
    async fn find_by_id(&self, id: Uuid) -> RepositoryResult<Option<User>>;
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\mod.rs
File type: .rs
pub mod database;
pub mod repositories;
pub mod security;
pub mod storage;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\database\mod.rs
File type: .rs
pub mod sqlite;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\database\sqlite.rs
File type: .rs
use sqlx::SqlitePool;

#[derive(Clone)]
pub struct Sqlite {
    pool: SqlitePool,
}

impl Sqlite {
    pub async fn new(database_url: String) -> Result<Self, Box<dyn std::error::Error>> {
        let db_pool = SqlitePool::connect(&database_url)
            .await
            .expect("Failed to create SQLite connection pool");

        Ok(Self { pool: db_pool })
    }

    pub fn get_pool(&self) -> SqlitePool {
        self.pool.clone()
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\repositories\mod.rs
File type: .rs
pub mod sqlite_report_repository;
pub mod sqlite_user_repository;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\repositories\sqlite_report_repository.rs
File type: .rs
use async_trait::async_trait;

use chrono::{DateTime, Utc};
use sqlx::SqlitePool;
use uuid::Uuid;

use crate::domain::{
    models::report::{Report, ReportType},
    repositories::{RepositoryResult, map_sqlx_error, report_repository::ReportRepository},
};

#[derive(Clone)]
pub struct SqliteReportRepository {
    pool: SqlitePool,
}

impl SqliteReportRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl ReportRepository for SqliteReportRepository {
    async fn create_report(
        &self,
        user_id: Uuid,
        title: String,
        report_type: ReportType,
        description: Option<String>,
        file_path: String,
        url: Option<String>,
    ) -> RepositoryResult<Report> {
        let report_id = Uuid::new_v4();

        let result = sqlx::query_as!(
            Report,
            r#"
            INSERT INTO reports (id, user_id, report_type, title, description, file_path, url)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            RETURNING
                id as "id: uuid::Uuid",
                user_id as "user_id: uuid::Uuid",
                report_type as "report_type: ReportType",
                title,
                description,
                file_path,
                url,
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            "#,
            report_id,
            user_id,
            report_type,
            title,
            description,
            file_path,
            url,
        )
        .fetch_one(&self.pool)
        .await;

        match result {
            Ok(report) => Ok(report),
            Err(e) => Err(map_sqlx_error(e)),
        }
    }

    async fn get_report(&self, id: Uuid) -> RepositoryResult<Option<Report>> {
        sqlx::query_as!(
            Report,
            r#"
            SELECT 
                id as "id: uuid::Uuid",
                user_id as "user_id: uuid::Uuid",
                report_type as "report_type: ReportType",
                title,
                description,
                file_path,
                url,
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM reports
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\repositories\sqlite_user_repository.rs
File type: .rs
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use sqlx::SqlitePool;
use uuid::Uuid;

use crate::domain::{
    models::user::{User, UserRole},
    repositories::{RepositoryResult, map_sqlx_error, user_repository::UserRepository},
};

#[derive(Clone)]
pub struct SqliteUserRepository {
    pool: SqlitePool,
}

impl SqliteUserRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for SqliteUserRepository {
    async fn create_user(
        &self,
        email: &str,
        password_hash: &str,
        first_name: Option<&str>,
        last_name: Option<&str>,
        role: UserRole,
    ) -> RepositoryResult<User> {
        let user_id = Uuid::new_v4();

        let result = sqlx::query_as!(
            User,
            r#"
            INSERT INTO users (id, email, password_hash, first_name, last_name, role)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING
                id as "id: uuid::Uuid",
                email,
                password_hash,
                first_name,
                last_name,
                role as "role: UserRole",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            "#,
            user_id,
            email,
            password_hash,
            first_name,
            last_name,
            role
        )
        .fetch_one(&self.pool)
        .await;

        match result {
            Ok(user) => Ok(user),
            Err(e) => Err(map_sqlx_error(e)),
        }
    }

    async fn find_by_email(&self, email: &str) -> RepositoryResult<Option<User>> {
        sqlx::query_as!(
            User,
            r#"
            SELECT
                id as "id: uuid::Uuid",
                email,
                password_hash,
                first_name,
                last_name,
                role as "role: UserRole",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM users
            WHERE email = $1
            "#,
            email
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }

    async fn find_by_id(&self, id: Uuid) -> RepositoryResult<Option<User>> {
        sqlx::query_as!(
            User,
            r#"
            SELECT
                id as "id: uuid::Uuid",
                email,
                password_hash,
                first_name,
                last_name,
                role as "role: UserRole",
                created_at as "created_at: DateTime<Utc>",
                updated_at as "updated_at: DateTime<Utc>"
            FROM users
            WHERE id = $1 
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(map_sqlx_error)
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\security\mod.rs
File type: .rs
pub mod password_hasher;


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\security\password_hasher.rs
File type: .rs
use bcrypt::{DEFAULT_COST, hash, verify};

#[derive(Debug, thiserror::Error)]
pub enum PasswordError {
    #[error("Failed to hash password: {0}")]
    HashingError(String),
    #[error("Failed to verify password: {0}")]
    VerificationError(String),
    #[error("Invalid password")]
    InvalidPassword,
}

pub type PasswordResult<T> = Result<T, PasswordError>;

pub fn hash_password(password: &str) -> PasswordResult<String> {
    hash(password, DEFAULT_COST).map_err(|e| PasswordError::HashingError(e.to_string()))
}

pub fn verify_password(password: &str, hashed_password: &str) -> PasswordResult<bool> {
    verify(password, hashed_password).map_err(|e| PasswordError::VerificationError(e.to_string()))
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\storage\file_system_storage.rs
File type: .rs
use async_trait::async_trait;
use bytes::Bytes;
use chrono::Utc;
use std::path::Path;
use tokio::fs;

use crate::domain::ports::storage_port::{StorageError, StoragePort, StorageResult};

#[derive(Clone)]
pub struct FileSystemStorage {
    upload_directory: String,
}

impl FileSystemStorage {
    pub fn new(upload_directory: String) -> StorageResult<Self> {
        let path = Path::new(&upload_directory);
        if !path.exists() {
            std::fs::create_dir_all(path).map_err(|e| {
                StorageError::ConfigurationError(format!(
                    "Failed to create upload directory '{}': {}",
                    upload_directory, e
                ))
            })?;
        }
        Ok(Self { upload_directory })
    }
}

#[async_trait]
impl StoragePort for FileSystemStorage {
    // TODO: maybe just use the file extension from the original file name
    async fn save_file(&self, original_file_name: &str, data: Bytes) -> StorageResult<String> {
        let timestamp = Utc::now().timestamp_millis();

        let safe_original_name = original_file_name
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-' || *c == '_')
            .collect::<String>();
        let unique_file_name = format!("{}_{}", timestamp, safe_original_name);

        let full_path = Path::new(&self.upload_directory).join(&unique_file_name);

        fs::write(&full_path, data)
            .await
            .map_err(|e| StorageError::SaveFailed(e.to_string()))?;

        Ok(unique_file_name.to_string())
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src/infrastructure\storage\mod.rs
File type: .rs
pub mod file_system_storage;


--------------------------------------------------
File End
--------------------------------------------------
